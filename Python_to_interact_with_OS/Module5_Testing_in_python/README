unittest
A unittest provides developers with a set of tools to construct and run tests. These tests can be run on individual components or by isolating units of code to ensure their correctness. By running unittests, developers can identify and fix any bugs that appear, creating a more reliable code. In this reading, you will learn about unittest concepts, how to use and when to use them, and view an example along the way.

Concepts
Unittest relies on the following concepts:

Test fixture: This refers to preparing to perform one or more tests. In addition, test fixtures also include any actions involved in testing cleanup. This could involve creating temporary or proxy databases, directories, or starting a server process.

Test case: This is the individual unit of testing that looks for a specific response to a set of inputs. If needed, TestCase is a base class provided by unittest and can be used to create new test cases.

Test suite: This is a collection of test cases, test suites, or a combination of both. It is used to compile tests that should be executed together.

Test runner: This runs the test and provides developers with the outcome’s data. The test runner can use different interfaces, like graphical or textual, to provide the developer with the test results. It can also provide a special value to developers to communicate the test results. 

Use case
Let’s look at a test case example where the Python code simulates a cake factory and performs different functions. These include choosing different sizes and flavors of a cake, including small, medium, and large, and chocolate or vanilla. In addition, the simple class allows developers to add sprinkles or cherries to the cake, return a list of ingredients, and return the price of the cake based on size and toppings. Run the following code: 
cake_factory.py

In the code above, the cake factory class and methods are defined. Now it’s time to define the unittest methods to test the different functions of the code. The test suite includes tests for the cake’s flavor, size, toppings, ingredients, and price. The first test case in the suite will intentionally provide the wrong value—and that’s what we want! Create specific statements to make sure the program is behaving as it should. That includes providing incorrect data to determine if the program will provide failed results. Because unittest is class-based,  encapsulate these statements into test methods. 

USE of assert: 
An assert is a commonly used debugging tool in Python that allows programmers to include sanity checks in their code. They ensure certain conditions or assumptions hold true during runtime. If the condition provided to assert() turns out to be false, it indicates a bug in the code, an exception is raised, and halts the program’s execution. Typically, code provides an assert condition followed by an optional message. 

def divide(a, b):
	assert b != 0, "Cannot divide by zero"
	return a / b

Pytest fixtures:
Fixtures are used to separate parts of code that only run for tests. They are reusable pieces of test setups and teardown code that are shared across multiple tests. Fixtures benefit developers by assisting in keeping their tests clean and avoiding code duplication. Let’s look at an example of using a pytest in Python:

Edge cases are inputs to our code that produce unexpected results, and are found at the extreme ends of the ranges of input we imagine our programs will typically work with. Edge cases usually need special handling in scripts in order for the code to continue to behave correctly.


The TestCase class also employs its own assert methods that work similarly to the assert statement: if a test fails, an exception is raised with an explanatory message, and unittest identifies the test case as a failure. In the above example, there are several assertions used:

An assertEqual() to check for an expected result

An assertTrue() and an assertFalse() to verify a condition

An assertRaises() to verify that a specific exception gets raised

Each of these assert methods is used in place of the standard assert statement so the test runner can gather all the test results and generate a report.


Below is a list of commonly used assert methods in the TestCase class. For more information on each method, select the embedded link in the list provided.    

The 
assertEqual(a, b)
 method checks that a == b

The 
assertNotEqual(a, b)
 method checks that a != b

The 
assertTrue(x)
 method checks that bool(x) is True

The 
assertFalse(x)
 method checks that bool(x) is False

The 
assertIs(a, b)
 method checks that a is b

The 
assertIsNot(a, b)
 method checks that a is not b

The 
assertIsNone(x)
 method checks that x is None

The 
assertIsNotNone(x)
 method checks that x is not None

The 
assertIn(a, b)
 method checks that a in b

The 
assertNotIn(a, b)
 method checks that a not in b

The 
assertIsInstance(a, b)
 method checks that isinstance(a, b)

The 
assertNotIsInstance(a, b)
 method checks that not isinstance(a,  

You can also use assert methods to generate exceptions, warnings, and log messages. For example, another important assert method in unit testing is assertRaises. It allows you to test whether exceptions are raised when they should be, ensuring that your program can handle errors. assertRaises also allows developers to check which specific exception type is raised, ensuring that the correct error handling is in place.

Command-line interface
The command-line interface allows you to interact with an application or program through your operating system command line, terminal, or console by beginning your code with a text command. When you want to run tests in Python, you can use the unittest module from the command line to run tests from modules, classes, or even individual test methods. This also allows you to run multiple files at one time. 

To call an entire module:

python -m unittest test_module1 test_module2 

To call a test class:

python -m unittest test_module.TestClass

To call a test method:

python -m unittest test_module.TestClass.test_method

Test modules can also be called using a file path, as written below:

python -m unittest tests/test_something.py

[source: 
https://docs.python.org/3/library/unittest.html
]


In each instance, the structure of the command remained the same, with the test class and test method being added to the original module that was called. 

You can also use the command line for test discovery, for running all of the tests in a single project, or even for just a subset of tests. 

Check out the following links for more information:

https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/

https://landing.google.com/sre/sre-book/chapters/testing-reliability/

https://testing.googleblog.com/2007/10/performance-testing.html

https://www.guru99.com/smoke-testing.html

https://www.guru99.com/exploratory-testing.html

https://testing.googleblog.com/2008/09/test-first-is-fun_08.html

Study guide: Handling errors
You’ve learned that in some cases, it’s better to raise an error yourself, and how to test that the right error is raised when that's what you expect. You’ve also learned how to test your code to verify that it does what it should. In this reading, you’ll learn about error handling syntax, including raising exceptions, using an assert statement, and the try and except clauses. 

Exception handling
When performing exception handling, it is important to predict which exceptions can happen. Sometimes, to figure out which exceptions you need to account for, you have to let your program fail.

The simplest way to handle exceptions in Python is by using the try and except clauses. 

In the try clause, Python executes all statements until it encounters an exception. You use the except clause to catch and handle the exception(s) that Python encounters in the try clause.

Here is the process for how it works: 

Python runs the try clause, e.g., the statement(s) between the try and except keywords.

If no error occurs, Python skips the except clause and the execution of the try statement is finished.

If an error occurs during execution of the try clause, Python skips the rest of the try clause and transfers control to the corresponding except block. If the type of error matches what is listed after the except keyword, Python executes the except clause. The execution then continues on after the try/except block.

If an exception occurs but it does not match what is listed in the except clause, it is passed onto try statements outside of that try/except block. However, if a handler for that exception cannot be found, the exception becomes an unhandled exception, the execution stops, and Python displays a designated error message. 

Sometimes, a try statement can have more than one except clause so that the code can specify handlers for different exceptions. This can help to reduce the number of unhandled exceptions. 

You can use exceptions to catch almost everything. It is good practice as a developer or programmer to be as specific as possible with the types of exceptions that you intend to handle, especially if you’re creating your own exceptions.  

Raise exceptions
As a developer or programmer, you might want to raise an error yourself. Usually, this happens when some of the conditions necessary for a function to do its job properly aren't met and returning none or some other base value isn't good enough. You can raise an error or raise an exception (also known as “throwing an exception”), which forces a particular exception to occur, and notifies you that something in your code is going wrong or an error has occurred. 

Here are some instances where raising an exception is a useful tool:

A file doesn’t exist

A network or database connection fails

Your code receives invalid input

In the example below, the code raises two built-in Python exceptions:  raise ValueError and raise ZeroDivisionError. You can find more information on these raises in the example below, along with explanations of potential errors that may occur during an exception.

Example exception handling
Now that you have an understanding of try and except clauses, assert statements, and raising exceptions, consider the following code examples which use all of these concepts together.

The basic structure of exception handling is as follows: 

123456789
# File reading function with exception handling
def read_file(filename):
	try:
		with open(filename, 'r') as f:
			return f.read()
	except FileNotFoundError:
		return "File not found!"
	finally:
		print("Finished reading file.")
Imagine you have a function that reads data from a file and then divides two numbers provided within that file. There are some faults in it that you can catch with exceptions.

123456
def faulty_read_and_divide(filename):
	with open(filename, 'r') as file:
		data = file.readlines()
		num1 = int(data[0])
		num2 = int(data[1])
		return num1 / num2
There are several potential issues here:

The file might not exist, causing a FileNotFoundError.

The file might not have enough lines of data, leading to an IndexError.

The data in the file might not be convertible to integers, raising a ValueError.

The second number might be zero, which would raise a ZeroDivisionError.

To address these potential issues, you can add the appropriate exception handling illustrated below:

12345678910111213141516171819202122232425
def enhanced_read_and_divide(filename):
	try:
		with open(filename, 'r') as file:
			data = file.readlines()
       	 
        # Ensure there are at least two lines in the file
        if len(data) < 2:
            raise ValueError("Not enough data in the file.")
       	 
        num1 = int(data[0])

Now, the function enhanced_read_and_divide is equipped to handle potential exceptions gracefully, providing informative error messages to the caller. This way, the code will explain when it fails since you have identified potential fault zones such as when dealing with unpredictable inputs or file content.

Notice how the exceptions are instantiated as objects (such as ValueError ve) that you can use to further diagnose the issue by printing them out.


The errors should read:

File-level issues:

Value error: Not enough data in the file.

Error: The file was not found.

Data-level issues:

Value error: invalid literal for int() with base 10: 'apple'

Division error: The denominator is zero.


assert statements
assert statements help you to verify if a certain condition is met and throw an exception if it isn’t. As is stated in the name, their purpose is to "assert" that certain conditions are true at specific points in your program. 

The assert statement exists in almost every programming language and has two main uses:

To help detect problems earlier in development, rather than later when some other operation fails. Problems that aren’t addressed until later in the development process can turn out to be more time-intensive and costly to fix.

To provide a form of documentation for other developers reading the code.

You can learn more about common assertions that you might use when handling errors in 
Study guide: Unit test
.

Key takeaways
For a bit of light reading, or for more information on raising exceptions, assertions, the try clause, exceptions, or handling errors, visit the following links:

https://doughellmann.com/posts/python-exception-handling-techniques

https://docs.python.org/3/tutorial/errors.html#raising-exceptions
 

https://realpython.com/python-exceptions/

https://realpython.com/python-raise-exception/#handling-exceptional-situations-in-python

Glossary terms from course 2, module 5
Terms and definitions from Course 2, Module 5
Automatic testing: A process where software checks itself for errors and confirms that it works correctly

Black-box tests: A test where there is an awareness of what the program is supposed to do but not how it does it

Edge cases: Inputs to code that produce unexpected results, found at the extreme ends of the ranges of input

Pytest: A powerful Python testing tool that assists programmers in writing more effective and stable programs

Software testing: A process of evaluating computer code to determine whether or not it does what is expected

Test case: This is the individual unit of testing that looks for a specific response to a set of inputs

Test fixture: This prepared to perform one or more tests

Test suite: This is used to compile tests that should be executed together

Test runner: This runs the test and provides developers with the outcome’s data

unittest: A set of Python tools to construct and run unit tests

Unit tests: A test to verify that small isolated parts of a program work correctly

White-box test: A test where test creator knows how the code works and can write test cases that use the understanding to make sure it performs as expected
