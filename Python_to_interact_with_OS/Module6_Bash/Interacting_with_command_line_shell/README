mkdir mynewdir
cd mynewdir/
/mynewdir$ pwd
/mynewdir$ cp ../spider.txt .
/mynewdir$ touch myfile.txt
/mynewdir$ ls -l 
#Output:
#-rw-rw-r-- 1 user user   0 Mai 22 14:22 myfile.txt #create a empty file
#-rw-rw-r-- 1 user user 192 Mai 22 14:18 spider.txt
/mynewdir$ ls -la
#Output:
#total 12
#drwxr-xr-x  2 user user  4096 Mai 22 14:17 .
#drwxr-xr-x 56 user user 12288 Mai 22 14:17 ..
#-rw-rw-r--  1 user user     0 Mai 22 14:22 myfile.txt
#-rw-rw-r--  1 user user   192 Mai 22 14:18 spider.txt
/mynewdir$ mv myfile.txt emptyfile.txt
/mynewdir$ cp spider.txt yetanotherfile.txt
/mynewdir$ ls -l
#Output:
#total 8
#-rw-rw-r-- 1 user user   0 Mai 22 14:22 emptyfile.txt
#-rw-rw-r-- 1 user user 192 Mai 22 14:18 spider.txt
#-rw-rw-r-- 1 user user 192 Mai 22 14:23 yetanotherfile.txt
/mynewdir$ rm *
/mynewdir$ ls -l
#total 0
/mynewdir$ cd ..
rmdir mynewdir/
ls mynewdir
#ls: cannot access 'mynewdir': No such file or directory


Basic Linux commands are beneficial to developers when interacting with a Linux operating system through the command line interface. They are used when working with files and directories. Typically, they are easy to learn and apply, and provide developers with additional commands for more advanced situations. If needed, these commands are also easy to look up on your preferred search engine.

In this reading, you will review basic Linux commands with examples provided along the way.

Managing files and directories
Many applications configure themselves by reading files. They are designed to read and write files in specific directories. Because of this, developers need to understand how to move and rename files, change their permissions, and do simple operations on their contents. Here are some common commands:

mv is used to move one or more files to a different directory, rename a file, or both at the same time.

Note: Linux is case-sensitive, so mv can also be used to change the case of a filename.

mv myfile.txt dir1/ This command moves a file to the directory.

mv file1.txt file2.txt file3.txt dir1/ This command moves multiple files.


cp is used to copy one or more files. Some examples include:

cp file1.txt file2.txt 

cp file1.txt file2.txt file3.txt dir1/


chmod/chown/chgrp is used to make a file readable to everyone on the system before moving it to a public directory. A common example is:

chmod +r file.html && mv file.html /var/www/html/index.html 

Operating with the content of files
Every programmer will use files for something. Whether it’s for configuration, data, or input and output, programmers work with files and need to know how to operate with their contents.

cut is a command that extracts fields from a data file. Two examples are:

cut -f1 -d”,” addressbook.csv This command extracts the first field from a .csv file.

cut -c1-3,5-7,9-12 phones.txt This command extracts only the digits from a list of phone numbers.


sort is a command that sorts the contents of a file. Some examples include:

sort names.txt This command sorts inputs alphabetically.

sort -r names.txt This command sorts inputs in reverse alphabetical order, starting with the letter z. 

sort -n numbers.txt This command treats the inputs as numbers and then sorts them numerically.


Some examples that include combining multiple commands are:

ls -l | cut -w -f5,9 | sort -rn | head -10 This command displays the 10 largest files in the current directory.


cut -f1-2 -d”,” addressbook.csv | sort This command extracts the first and last names from a .csv file and sorts them.

Additional commands
Additional commands that programmers commonly use are:

id  is a command that prints information about the current user. This command is useful if you are getting a permissions denied error and think you should be granted access to a file.

$ id

uid=3000(tradel) gid=3000(tradel) groups=3000(tradel),0(root),100(users),545(builtin_users),999(docker)


free is a command that prints information about memory on the current system.

free -h This command prints in human-readable units instead of bytes.

Key takeaways
Basic Linux commands assist developers in different types of tasks related to managing files and directories and working with the content of each file. These commands allow developers to work more efficiently and effectively.

Redirections, Pipes, and Signals
Managing streams
These are the redirectors that we can use to take control of the streams of our programs

command > file: redirects standard output, overwrites file

command >> file: redirects standard output, appends to file

command < file: redirects standard input from file

command 2> file: redirects standard error to file

command1 | command2: connects the output of command1 to the input of command2

Operating with processes
These are some commands that are useful to know in Linux when interacting with processes. Not all of them are explained in videos, so feel free to investigate them on your own.

ps: lists the processes executing in the current terminal for the current user

ps ax: lists all processes currently executing for all users  

ps e: shows the environment for the processes listed  

kill PID: sends the SIGTERM signal to the process identified by PID

fg: causes a job that was stopped or in the background to return to the foreground

bg: causes a job that was stopped to go to the background

jobs: lists the jobs currently running or stopped

top: shows the processes currently using the most CPU time (press "q" to quit)  

Check out the following links for more information:

https://ryanstutorials.net/bash-scripting-tutorial/

https://linuxconfig.org/bash-scripting-tutorial-for-beginners

https://www.shellscript.sh

IT skills in action reading
Congratulations! You have gained so much knowledge about using Python to interact with your operating system. There are many technical pieces that are included while using regexes in your code, but how would you apply the skills you learned in a professional setting?

In this reading, you will review an example of how regular expressions are used in the real world.

Disclaimer: The following scenario is based on a fictitious company called LogicLink Innovations.

Time is ticking
Dakota is a fairly new programmer with his company. He just earned a spot on the project for LogicLink Innovations. This is one of the biggest and most credible companies in the industry, so Dakota knows he has to excel on this project to help make a name for himself. LogicLink Innovations manages customer data and has hundreds of customer phone numbers in its database. The phone numbers are in inconsistent formats. Some are written with dashes, some in parentheses with spaces, and some are just digits. Dakota sees this:

123-456-7890

(123) 456-7890

1234567890


Dakota is assigned to take the dataset containing phone numbers and organize the formatting so they are all consistent. His manager tells him they need it by the end of the week! There is no way Dakota can work through and edit hundreds of phone numbers. There has to be another way.

Search and replace
Dakota remembers reading about how other programmers use regular expressions to make their coding life easier. He knows there has to be one that can help him with his dilemma. This can’t be the first time a programmer needs to standardize numbers! He decides to craft a regular expression that captures three groups of digits, each of which might be surrounded by non-digit characters.


Using a regex tool and the sample data from above, he eventually comes up with a regex that matches all three samples:

^\D*(\d{3})\D*(\d{3})\D*(\d{4})$


Let’s break down this line of code, piece by piece:

^\D*

This part of the code matches zero or more non-digit characters at the beginning of the string.

(\d{3})

This part of the code captures exactly three digits, which represent the area code.

\D*

This part of the code matches zero or more non-digit characters between the area code and exchange.

(\d{3} ) 

This part of the code captures the three-digit exchange.

\D*       

This part of the code matches zero or more non-digit characters between the exchange and line.

(\d{4})$

This part of the code captures exactly four digits at the end of the string.

    

Now he has three capture groups: area code, exchange, and number. He then substitutes those groups into a new string using backreferences:

(\1) \2-\3


This puts all of the phone numbers into a uniform format.


This regular expression helps Dakota by searching for phone numbers in different formats and replacing them to match the format that Dakota’s manager needs: (123) 456-7890. Dakota begins to code.


He writes up a simple Python script to read the dataset from a file and output the corrected phone numbers using his regular expressions:

import re


with open("data/phones.csv", "r") as phones:

 for phone in phones:

   new_phone = re.sub(r"^\D*(\d{3})\D*(\d{3})\D*(\d{4})$", r"(\1) \2-\3", phone)

   print(new_phone)

(123) 456-7890

(123) 456-7890

(123) 456-7890


Success! Dakota gets the project done in a single day and is now the office hero. 

A happy client
By using a regular expression, Dakota expedited the process of collecting, organizing, and providing LogicLink Innovation with its customers’ phone numbers, all in the same format.